generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  STUDENT
  CREATOR
  ADMIN
}

enum TestVisibility {
  PUBLIC
  PRIVATE
  GROUP_ONLY
}

enum TestStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum QuestionType {
  MCQ
  MSQ
  NUMERICAL
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum AttemptStatus {
  IN_PROGRESS
  SUBMITTED
  EXPIRED
}

model User {
  id           String    @id @default(cuid())
  email        String    @unique
  name         String?
  passwordHash String
  role         UserRole  @default(STUDENT)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  sessions     Session[]
  createdTests Test[]    @relation("creatorTests")
  questions    Question[]
  attempts     Attempt[]
  pdfDocuments PdfDocument[]

  // Phase 5: Groups
  ownedGroups          Group[]              @relation("UserOwnedGroups")
  groupMemberships     GroupMember[]
  groupInvitesCreated  GroupInvite[]
  groupAssignmentsMade GroupTestAssignment[]

  // Phase 5: Community
  solutionPosts        SolutionPost[]
  solutionUpvotes      SolutionUpvote[]
  solutionComments     SolutionComment[]

  // Phase 5: Reports / moderation
  reportsMade          ContentReport[]      @relation("reporter")
  reportsResolved      ContentReport[]      @relation("resolver")
}
  
model Session {
  id        String   @id @default(cuid())
  userId    String
  tokenHash String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model Test {
  id            String         @id @default(cuid())
  creatorId     String
  title         String
  description   String?
  instructions  String?
  visibility    TestVisibility @default(PRIVATE)
  status        TestStatus     @default(DRAFT)

  durationSec   Int            // total test time
  defaultMarks  Float          @default(4)
  defaultNegative Float        @default(-1)

  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  creator       User           @relation("creatorTests", fields: [creatorId], references: [id], onDelete: Restrict)
  sections      TestSection[]
  testQuestions TestQuestion[]
  attempts      Attempt[]
  groupAssignments GroupTestAssignment[]
  @@index([creatorId])
  @@index([status, visibility])
}

model TestSection {
  id         String   @id @default(cuid())
  testId     String
  name       String
  sortOrder  Int
  // optional per-section timing in Phase 3 if you want section timers
  durationSec Int?

  test Test @relation(fields: [testId], references: [id], onDelete: Cascade)

  testQuestions TestQuestion[]

  @@unique([testId, sortOrder])
  @@index([testId])
}

model Question {
  id              String       @id @default(cuid())
  creatorId        String
  type            QuestionType
  difficulty      Difficulty   @default(MEDIUM)

  subject         String?
  chapter         String?

  promptImageUrl  String
  optionsImageUrl String?

  answerKeyJson   Json

  solutionText     String?
  solutionImageUrl String?
  solutionPosts SolutionPost[]

  marks           Float        @default(4)
  negativeMarks   Float        @default(-1)

  // NEW: link question back to PDF + crop (Phase 2)
  sourcePdfId     String?
  sourceCropId    String?

  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  creator         User         @relation(fields: [creatorId], references: [id], onDelete: Restrict)
  testQuestions   TestQuestion[]
  attemptAnswers  AttemptAnswer[]

  // NEW relations (require PdfDocument + PdfCrop models to exist)
  sourcePdf       PdfDocument? @relation(fields: [sourcePdfId], references: [id], onDelete: SetNull)
  sourceCrop      PdfCrop?     @relation(fields: [sourceCropId], references: [id], onDelete: SetNull)
  

  @@index([creatorId])
  @@index([type])

  // NEW indexes (recommended)
  @@index([sourcePdfId])
  @@index([sourceCropId])
}

model TestQuestion {
  id          String  @id @default(cuid())
  testId      String
  questionId  String
  sectionId   String?
  sortOrder   Int

  // overrides (nullable => use question.marks / question.negativeMarks)
  marksOverride        Float?
  negativeMarksOverride Float?

  test     Test     @relation(fields: [testId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Restrict)
  section  TestSection? @relation(fields: [sectionId], references: [id], onDelete: SetNull)

  @@unique([testId, sortOrder])
  @@index([testId])
  @@index([questionId])
}

model Attempt {
  id         String        @id @default(cuid())
  testId     String
  studentId  String
  status     AttemptStatus @default(IN_PROGRESS)

  startedAt  DateTime      @default(now())
  endsAt     DateTime
  submittedAt DateTime?
  lastSeenAt DateTime      @default(now())

  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  test       Test          @relation(fields: [testId], references: [id], onDelete: Cascade)
  student    User          @relation(fields: [studentId], references: [id], onDelete: Restrict)

  answers    AttemptAnswer[]
  result     AttemptResult?

  @@index([testId])
  @@index([studentId])
  @@index([status, endsAt])
}

model AttemptAnswer {
  attemptId   String
  questionId  String

  // Student response:
  // MCQ: { "option": 1 }
  // MSQ: { "options": [0,3] }
  // NUM: { "value": "2.5" }
  responseJson Json?

  visited     Boolean @default(false)
  isMarked    Boolean @default(false)

  timeSpentMs Int     @default(0)

  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())

  attempt Attempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id], onDelete: Restrict)

  @@id([attemptId, questionId])
  @@index([questionId])
}

model AttemptResult {
  attemptId        String  @id
  score            Float
  maxScore         Float

  correctCount     Int
  wrongCount       Int
  unattemptedCount Int

  accuracy         Float   // correct / attempted (0..1), attempted excludes unattempted
  totalTimeMs      Int

  // optional rollups for analysis pages (Phase 4)
  subjectBreakupJson Json?

  createdAt        DateTime @default(now())

  attempt Attempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
}

enum PdfStatus {
  UPLOADING
  READY
  FAILED
}

enum GroupMemberRole {
  OWNER
  MOD
  MEMBER
}

enum ContentStatus {
  VISIBLE
  HIDDEN
  DELETED
}

enum ReportStatus {
  OPEN
  RESOLVED
  DISMISSED
}

enum ReportTargetType {
  SOLUTION_POST
  SOLUTION_COMMENT
  TEST
  QUESTION
}

model PdfDocument {
  id           String    @id @default(cuid())
  creatorId    String
  originalName String
  fileKey      String    @unique
  pageCount    Int?
  status       PdfStatus @default(UPLOADING)
  questions Question[]

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  creator      User      @relation(fields: [creatorId], references: [id], onDelete: Restrict)
  crops        PdfCrop[]

  @@index([creatorId])
  @@index([status])
}

model PdfCrop {
  id               String   @id @default(cuid())
  pdfId            String
  pageNumber       Int

  // Crop rectangles are stored in *rendered canvas pixel coordinates* for that scale.
  // Example: { "x": 120, "y": 240, "w": 900, "h": 540, "renderScale": 1.5 }
  questionCropJson Json
  optionsCropJson  Json?

  questionImageKey String   @unique
  questionImageUrl String

  optionsImageKey  String?  @unique
  optionsImageUrl  String?

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  pdf              PdfDocument @relation(fields: [pdfId], references: [id], onDelete: Cascade)
  questions        Question[]

  @@index([pdfId])
  @@index([pdfId, pageNumber])
}

model Group {
  id          String   @id @default(cuid())
  ownerId     String
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner       User     @relation("UserOwnedGroups", fields: [ownerId], references: [id], onDelete: Restrict)
  members     GroupMember[]
  invites     GroupInvite[]
  assignments GroupTestAssignment[]

  @@index([ownerId])
  @@index([createdAt])
}

model GroupMember {
  groupId  String
  userId   String
  role     GroupMemberRole @default(MEMBER)
  joinedAt DateTime        @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([groupId, userId])
  @@index([userId])
}

model GroupInvite {
  id          String   @id @default(cuid())
  groupId     String
  code        String   @unique
  createdById String
  expiresAt   DateTime?
  maxUses     Int?
  usesCount   Int      @default(0)
  createdAt   DateTime @default(now())

  group     Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  createdBy User  @relation(fields: [createdById], references: [id], onDelete: Restrict)

  @@index([groupId])
  @@index([expiresAt])
}

model GroupTestAssignment {
  id           String   @id @default(cuid())
  groupId      String
  testId       String
  assignedById String
  createdAt    DateTime @default(now())

  group      Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  test       Test  @relation(fields: [testId], references: [id], onDelete: Cascade)
  assignedBy User  @relation(fields: [assignedById], references: [id], onDelete: Restrict)

  @@unique([groupId, testId])
  @@index([groupId])
  @@index([testId])
}

model SolutionPost {
  id         String        @id @default(cuid())
  questionId String
  authorId   String
  bodyText   String
  imageUrl   String?
  status     ContentStatus @default(VISIBLE)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  author   User     @relation(fields: [authorId], references: [id], onDelete: Restrict)

  upvotes  SolutionUpvote[]
  comments SolutionComment[]

  @@index([questionId, createdAt])
  @@index([authorId, createdAt])
  @@index([status])
}

model SolutionUpvote {
  postId    String
  userId    String
  createdAt DateTime @default(now())

  post SolutionPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([postId, userId])
  @@index([userId])
}

model SolutionComment {
  id        String        @id @default(cuid())
  postId    String
  authorId  String
  bodyText  String
  status    ContentStatus @default(VISIBLE)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  post   SolutionPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  author User         @relation(fields: [authorId], references: [id], onDelete: Restrict)

  @@index([postId, createdAt])
  @@index([authorId, createdAt])
  @@index([status])
}

model ContentReport {
  id             String         @id @default(cuid())
  reporterId     String
  targetType     ReportTargetType
  targetId       String
  reason         String
  details        String?
  status         ReportStatus   @default(OPEN)
  createdAt      DateTime       @default(now())
  resolvedAt     DateTime?
  resolvedById   String?
  resolutionNote String?

  reporter   User  @relation("reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  resolvedBy User? @relation("resolver", fields: [resolvedById], references: [id], onDelete: SetNull)

  @@index([status, createdAt])
  @@index([targetType, targetId])
  @@index([reporterId])
}